import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import * as fs from 'fs';
import * as path from 'path';
import { execSync, spawnSync } from 'child_process';

const fixturesDir = path.join(__dirname, 'fixtures');
const configPath = path.join(__dirname, '..', 'dotnet-to-ts.config.json');
const outputPath = path.join(__dirname, '..', 'output', 'generated.ts');

function cleanup() {
  if (fs.existsSync(outputPath)) {
    fs.unlinkSync(outputPath);
  }
}

describe('CLI Tool', () => {
  beforeEach(() => {
    cleanup();
  });

  afterEach(() => {
    cleanup();
  });

  it('should generate TypeScript definitions from C# fixture via CLI', () => {
    expect(fs.existsSync(configPath)).toBe(true);
    expect(fs.existsSync(fixturesDir)).toBe(true);

    const cliBin = path.join(__dirname, '..', 'dist', 'cli.js');
    const output = execSync(`node ${cliBin}`, { encoding: 'utf-8' });

    // Assert logs
    expect(output).toMatch(/dotnet-to-ts/);
    expect(output).toMatch(/Loaded config/);
    expect(output).toMatch(/Found \d+ C# files/);
    expect(output).toMatch(/Parsed \d+ classes/);
    expect(output).toMatch(/Written TypeScript interfaces to:/);
    expect(output).toMatch(/Done/);

    // Assert file written and content
    expect(fs.existsSync(outputPath)).toBe(true);
    const tsContent = fs.readFileSync(outputPath, 'utf-8');
    expect(tsContent).toMatch(/Auto-generated by dotnet-to-ts/);
    expect(tsContent).toMatch(/export interface DepartmentDto/);
    expect(tsContent).toMatch(/export interface EmployeeDto/);
  });

  it('should error with missing config', () => {
    // Arrange
    const cliBin = path.join(__dirname, '..', 'dist', 'cli.js');
    const missingConfig = path.join(__dirname, 'not-found-config.json');

    // Act
    const result = spawnSync('node', [cliBin, missingConfig], {
      encoding: 'utf-8',
    });

    // Assert
    expect(result.status).not.toBe(0);
    expect(result.stderr).toMatch(/Failed to load config/);
  });

  it('should error with no matching files', () => {
    // Arrange: temp config pointing to no files
    const tempConfig = path.join(__dirname, 'temp-empty-config.json');
    fs.writeFileSync(
      tempConfig,
      JSON.stringify({
        input: ['tests/fixtures/Nonexistent/**/*.cs'],
        output: 'output/nowhere.ts',
      }),
    );

    const cliBin = path.join(__dirname, '..', 'dist', 'cli.js');

    // Act
    const result = spawnSync('node', [cliBin, tempConfig], {
      encoding: 'utf-8',
    });

    // Assert
    expect(result.status).not.toBe(0);
    expect(result.stderr).toMatch(/No C# files found/);

    fs.unlinkSync(tempConfig);
  });

  it('should error with malformed config', () => {
    // Malformed JSON
    const tempConfig = path.join(__dirname, 'malformed-config.json');
    fs.writeFileSync(tempConfig, "{ this is not: 'json',");

    const cliBin = path.join(__dirname, '..', 'dist', 'cli.js');

    // Act
    const result = spawnSync('node', [cliBin, tempConfig], {
      encoding: 'utf-8',
    });

    // Assert
    expect(result.status).not.toBe(0);
    expect(result.stderr).toMatch(/Invalid JSON in config file/);

    fs.unlinkSync(tempConfig);
  });

  it('should support a custom config path as argument', () => {
    // Arrange: create temp config pointing to fixtures
    const tempConfig = path.join(__dirname, 'temp-valid-config.json');
    fs.writeFileSync(
      tempConfig,
      JSON.stringify({
        input: ['tests/fixtures/**/*.cs'],
        output: 'output/generated.ts',
      }),
    );

    const cliBin = path.join(__dirname, '..', 'dist', 'cli.js');
    const result = spawnSync('node', [cliBin, tempConfig], {
      encoding: 'utf-8',
    });

    // Assert
    expect(result.stdout).toMatch(/Loaded config/);
    expect(fs.existsSync(outputPath)).toBe(true);
    fs.unlinkSync(tempConfig);
  });
});
