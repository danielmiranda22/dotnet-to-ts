/**
 * TypeScriptGenerator - Generates TypeScript interface code from parsed C# classes
 */

import { ParsedClass, Property } from '../parser/CSharpParser.js';
import { TypeMapper } from '../mapper/TypeMapper.js';

export interface GeneratorOptions {
  indentation?: string; // Default: 2 spaces
  addTimestamp?: boolean; // Add generation timestamp comment
  exportInterfaces?: boolean; // Add "export" keyword
  propertyNamingConvention?: 'camelCase' | 'PascalCase' | 'preserve'; // Property naming convention
}

export class TSGenerator {
  private typeMapper: TypeMapper;
  private options: Required<GeneratorOptions>;

  constructor(options: GeneratorOptions = {}) {
    this.typeMapper = new TypeMapper();

    // Set defaults
    this.options = {
      indentation: options.indentation ?? '  ', // 2 spaces
      addTimestamp: options.addTimestamp ?? true,
      exportInterfaces: options.exportInterfaces ?? true,
      propertyNamingConvention: options.propertyNamingConvention ?? 'preserve',
    };
  }

  /**
   * Generates TypeScript interface code from a parsed C# class
   * @param parsedClass
   * @returns TypeScript interface as a string
   */
  generate(parsedClass: ParsedClass): string {
    const lines: string[] = [];

    // Add header comment with timestamp (optional)
    if (this.options.addTimestamp) {
      lines.push('/**');
      lines.push(' * Auto-generated by dotnet-to-ts');
      lines.push(` * Generated on: ${new Date().toISOString()}`);
      lines.push(' * DO NOT EDIT MANUALLY');
      lines.push(' */');
      lines.push('');
    }

    const exportKeyword = this.options.exportInterfaces ? 'export ' : '';

    // Interface declaration
    lines.push(`${exportKeyword}interface ${parsedClass.name} {`);

    // Add properties
    if (parsedClass.properties.length === 0) {
      // Empty interface (edge case)
      lines.push(`${this.options.indentation}// No properties`);
    } else {
      parsedClass.properties.forEach((property) => {
        // Map C# type to TypeScript type
        const tsType = this.typeMapper.map(property.type ?? 'any');
        let propertyName = this.applyPropertyNameConvention(property);
        // Add property line
        lines.push(`${this.options.indentation}${propertyName}: ${tsType};`);
      });
    }

    // Close interface
    lines.push('}');
    // Join all lines with newlines
    return lines.join('\n');
  }

  private applyPropertyNameConvention(property: Property) {
    let propertyName = property.name ?? '';
    switch (this.options.propertyNamingConvention) {
      case 'camelCase':
        propertyName =
          propertyName.charAt(0).toLowerCase() + propertyName.slice(1);
        break;
      case 'PascalCase':
        propertyName =
          propertyName.charAt(0).toUpperCase() + propertyName.slice(1);
        break;
      case 'preserve':
      default:
        break;
    }
    return propertyName;
  }

  /**
   * Generates TypeScript interfaces for multiple parsed classes
   * @param parsedClasses
   * @returns TypeScript code as a string
   */
  generateMultiple(parsedClasses: ParsedClass[]): string {
    const interfaces = parsedClasses.map((parsedClass) =>
      this.generate(parsedClass),
    );

    // Join with double newline separator
    return interfaces.join('\n\n');
  }
}
